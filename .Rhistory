# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(0,ntime) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1), labels=c("meani","means") )
dataRaw_huge <- mxData( observed=select(data_huge, contains("load")), type="raw" )
growthCurveModel_huge <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:ntime),
latentVars=c("intercept","slope"),
dataRaw_mx_huge,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveModel_huge <- mxOption(growthCurveModel_huge, "Calculate Hessian", "No")
growthCurveModel_huge <- mxOption(growthCurveModel_huge, "Standard Errors"  , "No")
growthCurveFit_huge <- mxRun(growthCurveModel_huge)
#microbenchmark(mxRun(growthCurveModel_huge), times = 1)
sum_huge = summary(growthCurveFit_huge)
sum_huge
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr, OpenMx)
set.seed(123)
induce_missing <- function(v, p){
miss <- sample(c(0,1), length(v), replace = TRUE, prob = c(1-p, p))
ifelse(miss, NA, v)
}
get_testpars <- function(fit) {
select(parameterEstimates(fit), lhs, op, rhs, est, se, p = pvalue, z)
}
data_small <- data.frame(load_t1 = rep(1, 100))
for(i in 1:4){
name <- str_c("load_t", i)
data_small[[name]] <- i
}
data_small %<>% mutate(across(contains("load"), function(x)x+rnorm(100, 0, 0.1)))
## true model
# residual variances
resVars <- mxPath( from=c("t1","t2","t3","t4"), arrows=2,
free=TRUE, values = rnorm(4, 5, 2))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1.8,0.1,0.2), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(1,1,1,1) )
# slope loadings
sloLoads <- mxPath( from="slope", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = c("data.load_t1",
"data.load_t2",
"data.load_t3",
"data.load_t4"))
# manifest means
manMeans <- mxPath( from="one", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(0,0,0,0) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6), labels=c("meani","means") )
dataRaw_small <- mxData( observed=data_small, type="raw" )
growthCurveModel_small_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=c("t1","t2","t3","t4"),
latentVars=c("intercept","slope"),
dataRaw_small, resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
data_mx_small <- mxGenerateData(growthCurveModel_small_true)
dataRaw_mx_small <- mxData( observed=data_mx_small, type="raw" )
# residual variances
resVars <- mxPath( from=c("t1","t2","t3","t4"), arrows=2,
free=TRUE, values = c(1,1,1,1))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1,1,1), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(1,1,1,1) )
# slope loadings
sloLoads <- mxPath( from="slope", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = c("data.load_t1",
"data.load_t2",
"data.load_t3",
"data.load_t4"))
# manifest means
manMeans <- mxPath( from="one", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(0,0,0,0) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1), labels=c("meani","means") )
growthCurveModel_small <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:4),
latentVars=c("intercept","slope"),
dataRaw_mx_small,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit_small <- mxRun(growthCurveModel_small)
#microbenchmark(mxRun(growthCurveModel_small), times = 1)
sum_small = summary(growthCurveFit_small)
# big model ---------------------------------------------------------------
data_big <- data.frame(load_t1 = rep(1, 500))
for(i in 1:15){
name <- str_c("load_t", i)
data_big[[name]] <- i
}
data_big %<>% mutate(across(contains("load"), function(x)x+rnorm(500, 0, 0.1)))
## "true" values provided
resVars <- mxPath( from=str_c("t", 1:15), arrows=2,
free=TRUE, values = rnorm(15, mean = 5, sd = 1))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, labels=c("vari","cov","vars"),  values=c(1.8,0.1,0.2) )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:15), arrows=1,
free=FALSE,
labels = str_c("data.load_t", 1:15))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(0,15) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6),
labels=c("meani","means") )
dataRaw_big <- mxData( observed=data_big, type="raw" )
growthCurveModel_big_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t",1:15),
latentVars=c("intercept","slope"),
dataRaw_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
data_mx_big <- mxGenerateData(growthCurveModel_big_true)
dataRaw_mx_big <- mxData( observed=data_mx_big, type="raw" )
## starting values provided
resVars <- mxPath( from=str_c("t", 1:15), arrows=2,
free=TRUE, values = rep(1, 15))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, labels=c("vari","cov","vars"),  values=c(1,1,1) )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:15), arrows=1,
free=FALSE,
labels = str_c("data.load_t", 1:15))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(0,15) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1),
labels=c("meani","means") )
growthCurveModel_big <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:15),
latentVars=c("intercept","slope"),
dataRaw_mx_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveModel_big <- mxOption(growthCurveModel_big, "Calculate Hessian", "No")
growthCurveModel_big <- mxOption(growthCurveModel_big, "Standard Errors"  , "No")
# growthCurveFit_big_true <- mxRun(growthCurveModel_big_true)
growthCurveFit_big <- mxRun(growthCurveModel_big)
#sum_big_true <- summary(growthCurveFit_big_true)
#sum_big_nostart <- summary(growthCurveFit_big_nostart)
sum_big <- summary(growthCurveFit_big)
sum_big
# growthCurveFit_big_true <- mxRun(growthCurveModel_big_true)
growthCurveFit_big <- mxRun(growthCurveModel_big)
#sum_big_true <- summary(growthCurveFit_big_true)
#sum_big_nostart <- summary(growthCurveFit_big_nostart)
sum_big <- summary(growthCurveFit_big)
sum_big
growthCurveModel_big <- mxOption(growthCurveModel_big,
"Default optimizer	",
"NPSOL")
getOption('mxOptions')
growthCurveModel_big <- mxOption(growthCurveModel_big,
"Default optimizer",
"NPSOL")
mxOption(NULL,
"Default optimizer",
"NPSOL")
growthCurveFit_big <- mxRun(growthCurveModel_big)
?omxGetNPSOL()
omxGetNPSOL()
source('http://openmx.ssri.psu.edu/getOpenMx.R')
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr, OpenMx)
mxOption(NULL,
"Default optimizer",
"NPSOL")
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr, OpenMx)
set.seed(123)
#setwd(r"(C:\Users\maxim\.julia\dev\sem)")
induce_missing <- function(v, p){
miss <- sample(c(0,1), length(v), replace = TRUE, prob = c(1-p, p))
ifelse(miss, NA, v)
}
get_testpars <- function(fit) {
select(parameterEstimates(fit), lhs, op, rhs, est, se, p = pvalue, z)
}
# Definition Variables ----------------------------------------------------
# small model -------------------------------------------------------------
data_small <- data.frame(load_t1 = rep(1, 100))
for(i in 1:4){
name <- str_c("load_t", i)
data_small[[name]] <- i
}
data_small %<>% mutate(across(contains("load"), function(x)x+rnorm(100, 0, 0.1)))
## true model
# residual variances
resVars <- mxPath( from=c("t1","t2","t3","t4"), arrows=2,
free=TRUE, values = rnorm(4, 5, 2))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1.8,0.1,0.2), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(1,1,1,1) )
# slope loadings
sloLoads <- mxPath( from="slope", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = c("data.load_t1",
"data.load_t2",
"data.load_t3",
"data.load_t4"))
# manifest means
manMeans <- mxPath( from="one", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(0,0,0,0) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6), labels=c("meani","means") )
dataRaw_small <- mxData( observed=data_small, type="raw" )
growthCurveModel_small_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=c("t1","t2","t3","t4"),
latentVars=c("intercept","slope"),
dataRaw_small, resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
data_mx_small <- mxGenerateData(growthCurveModel_small_true)
dataRaw_mx_small <- mxData( observed=data_mx_small, type="raw" )
# residual variances
resVars <- mxPath( from=c("t1","t2","t3","t4"), arrows=2,
free=TRUE, values = c(1,1,1,1))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1,1,1), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(1,1,1,1) )
# slope loadings
sloLoads <- mxPath( from="slope", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = c("data.load_t1",
"data.load_t2",
"data.load_t3",
"data.load_t4"))
# manifest means
manMeans <- mxPath( from="one", to=c("t1","t2","t3","t4"), arrows=1,
free=FALSE, values=c(0,0,0,0) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1), labels=c("meani","means") )
growthCurveModel_small <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:4),
latentVars=c("intercept","slope"),
dataRaw_mx_small,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit_small <- mxRun(growthCurveModel_small)
#microbenchmark(mxRun(growthCurveModel_small), times = 1)
sum_small = summary(growthCurveFit_small)
# big model ---------------------------------------------------------------
data_big <- data.frame(load_t1 = rep(1, 500))
for(i in 1:15){
name <- str_c("load_t", i)
data_big[[name]] <- i
}
data_big %<>% mutate(across(contains("load"), function(x)x+rnorm(500, 0, 0.1)))
## "true" values provided
resVars <- mxPath( from=str_c("t", 1:15), arrows=2,
free=TRUE, values = rnorm(15, mean = 5, sd = 1))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, labels=c("vari","cov","vars"),  values=c(1.8,0.1,0.2) )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:15), arrows=1,
free=FALSE,
labels = str_c("data.load_t", 1:15))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(0,15) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6),
labels=c("meani","means") )
dataRaw_big <- mxData( observed=data_big, type="raw" )
growthCurveModel_big_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t",1:15),
latentVars=c("intercept","slope"),
dataRaw_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
data_mx_big <- mxGenerateData(growthCurveModel_big_true)
dataRaw_mx_big <- mxData( observed=data_mx_big, type="raw" )
## starting values provided
resVars <- mxPath( from=str_c("t", 1:15), arrows=2,
free=TRUE, values = rep(1, 15))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, labels=c("vari","cov","vars"),  values=c(1,1,1) )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:15), arrows=1,
free=FALSE,
labels = str_c("data.load_t", 1:15))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(0,15) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1),
labels=c("meani","means") )
growthCurveModel_big <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:15),
latentVars=c("intercept","slope"),
dataRaw_mx_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
mxOption(model= growthCurveModel_big, key="Number of Threads", value= 1)
growthCurveModel_big <- mxOption(growthCurveModel_big, "Calculate Hessian", "No")
growthCurveModel_big <- mxOption(growthCurveModel_big, "Standard Errors"  , "No")
# data_mx_big %>% select(starts_with("t")) %>% var() %>% diag()
# growthCurveFit_big_true <- mxRun(growthCurveModel_big_true)
growthCurveFit_big <- mxRun(growthCurveModel_big)
#true <- microbenchmark(mxRun(growthCurveModel_big_true), times = 1)
#nostart <- microbenchmark(mxRun(growthCurveModel_big_nostart), times = 1)
#withstart <- microbenchmark(mxRun(growthCurveModel_big_withstart), times = 1)
#sum_big_true <- summary(growthCurveFit_big_true)
#sum_big_nostart <- summary(growthCurveFit_big_nostart)
sum_big <- summary(growthCurveFit_big)
sum_big
mxOption(NULL,
"Default optimizer",
"NPSOL")
growthCurveFit_big <- mxRun(growthCurveModel_big)
sum_big <- summary(growthCurveFit_big)
sum_big
mxOption(growthCurveModel_big,
"Default optimizer",
"CSOLNP")
mxOption(NULL,
"Default optimizer",
"CSOLNP")
growthCurveFit_big <- mxRun(growthCurveModel_big)
sum_big <- summary(growthCurveFit_big)
sum_big
mxOption(NULL,
"Default optimizer",
"NPSOL")
growthCurveFit_big <- mxRun(growthCurveModel_big)
sum_big <- summary(growthCurveFit_big)
sum_big
sum_big$parameters %>% pull(Estimate)
test <- sum_big$parameters %>% pull(Estimate)
mxOption(NULL,
"Default optimizer",
"SLSQP")
# growthCurveFit_big_true <- mxRun(growthCurveModel_big_true)
growthCurveFit_big <- mxRun(growthCurveModel_big)
#sum_big_true <- summary(growthCurveFit_big_true)
#sum_big_nostart <- summary(growthCurveFit_big_nostart)
sum_big <- summary(growthCurveFit_big)
sum_big
sum_big$parameters %>% pull(Estimate)
sum_big$parameters %>% pull(Estimate) - test
mxOption(NULL,
"Default optimizer",
"NPSOL")
growthCurveFit_big <- mxRun(growthCurveModel_big)
sum_big <- summary(growthCurveFit_big)
sum_big
growthCurveFit_big
here()
getwd()
mxOption(NULL,
"Summary",
"log")
mxOption(NULL,
"Summary file",
"log")
growthCurveFit_big <- mxRun(growthCurveModel_big)
mxOption(NULL,
"Print file",
1)
growthCurveFit_big <- mxRun(growthCurveModel_big)
sum_big <- summary(growthCurveFit_big)
sum_big
mxOption(NULL,
"Summary file",
"log.txt")
growthCurveFit_big <- mxRun(growthCurveModel_big)
mxOption(NULL,
"Summary file",
1)
growthCurveFit_big <- mxRun(growthCurveModel_big)
x <- rnorm(100, mean = 0, sd = 0.1)
x <- rnorm(100, mean = 0, sd = 0.1)
y <- x + rnorm(100, 0, sd = 10)
cov(x,y)
var(x)
var(y)
5^(-2)
1(25)
1/25
#### repro-package ####
if(!requireNamespace("remotes"))install.packages("remotes")
if(!requireNamespace("repro"))remotes::install_github("aaronpeikert/repro")
#### Make/Docker ####
# follow instructions, rerun till you are told to not worry, then do not worry.
repro::check_make()
#### Make/Docker ####
# follow instructions, rerun till you are told to not worry, then do not worry.
repro::check_make()
#### Make/Docker ####
# follow instructions, rerun till you are told to not worry, then do not worry.
repro::check_make()
#### Make/Docker ####
# follow instructions, rerun till you are told to not worry, then do not worry.
repro::check_make()
repro::check_docker()
#### Git/GitHub
repro::check_git()
repro::check_github()
repro::check_github()
repro::check_github()
repro::check_github_token()
usethis::create_from_github("aaronpeikert/repro-workshop")
usethis::use_course("aaronpeikert/repro-workshop")
usethis::create_from_github(
"aaronpeikert/repro-workshop",
#creates new folder 'repro-workshop' at a
#default location, if you dont want this, uncomment:
#destdir = "path/to/some/folder",
fork = TRUE)
usethis::create_from_github(
"aaronpeikert/repro-workshop",
#creates new folder 'repro-workshop' at a
#default location, if you dont want this, uncomment:
#destdir = "path/to/some/folder",
fork = FALSE)
repro::check_github_token()
usethis::create_github_token()
gitcreds::gitcreds_set()
usethis::create_from_github(
"aaronpeikert/repro-workshop",
#creates new folder 'repro-workshop' at a
#default location, if you dont want this, uncomment:
#destdir = "path/to/some/folder",
fork = TRUE)
usethis::create_from_github("maximilian-stefan-ernst/repro-workshop")
usethis::create_from_github(
"aaronpeikert/repro-workshop")
usethis::create_from_github("aaronpeikert/repro-workshop")
pacman::p_load(here, feather, tidyverse, magrittr, ggplot2)
pacman::p_load(here, feather, tidyverse, magrittr, ggplot2)
pacman::p_load(here, feather, tidyverse, magrittr, ggplot2)
setwd(r"(C:\Users\maxim\.julia\dev\sem)")
BFGS_results = read_csv("test/comparisons/benchmark_big.csv")
BFGS_results %<>% mutate(is_finite = !is.infinite(minimum))
BFGS_results %>% ggplot() + geom_point(aes(x = line_search, y = is_finite))
BFGS_results %>% group_by(line_search) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% group_by(step_length) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% group_by(algo) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% group_by(line_search) %>% summarise(n_inf = sum(!truepars), n = n())
BFGS_results %>% group_by(step_length) %>% summarise(n_inf = sum(!truepars), n = n())
BFGS_results %>% group_by(algo) %>% summarise(n_inf = sum(!truepars))
BFGS_results %>% ggplot() +
geom_point(aes(x = line_search,
y = interaction(step_length, algo, m),
color = truepars,
shape = algo),
#position = position_jitter(width = 1),
alpha = 0.7) +
theme_minimal()
BFGS_results %<>% filter(truepars)
View(BFGS_results %>% arrange(line_search, step_length))
BFGS_results %>% ggplot() + geom_point(aes(x = algo, y = time,
color = line_search), alpha = .5)
BFGS_results %>% ggplot() + geom_point(aes(x = step_length, y = time))
BFGS_results %>% ggplot() + geom_point(aes(x = line_search, y = truepars))
BFGS_results %>% ggplot() + geom_point(aes(x = line_search, y = minimum))
BFGS_results %>% ggplot() +
geom_point(aes(x = step_length, y = time, color = factor(m),
group = interaction(line_search, algo, m)),
alpha = .5) +
facet_grid(rows = vars(line_search), cols = vars(algo)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
coord_cartesian(ylim=c(0, 30))
