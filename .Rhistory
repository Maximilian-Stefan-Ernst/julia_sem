manifestVars=str_c("t", 1:15),
latentVars=c("intercept","slope"),
dataRaw_mx_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit_big <- mxRun(growthCurveModel_big)
X1 = rnorm(0, 1, 100)
X2 = rnorm(0, 1, 100)
exp(c(1,2,3))
f_p <- function(x1, x2, b_1, b_2){
p = exp(x1*b_1 + x2*b_2)/(1 + exp(x1*b_1 + x2*b_2))
}
p = f_p(X1, X2, 2, 1)
p = f_p(X1, X2, 2, 1)
p
f_p(X1, X2, 2, 1)
X1 <- rnorm(0, 1, 100)
rnorm
X1 <- rnorm(100, 0, 1)
X2 <- rnorm(100, 0, 1)
f_p <- function(x1, x2, b_1, b_2){
p = exp(x1*b_1 + x2*b_2)/(1 + exp(x1*b_1 + x2*b_2))
}
p = f_p(X1, X2, 2, 1)
p
?sample
sample(c(0,1), size = 1, replace = T, prob = p)
c(p, 1-p)
map_dbl(p, ~sample(c(0,1), size = 1, replace = T, prob = c(.x, 1-.x)))
pacman::p_load(tidyverse)
map_dbl(p, ~sample(c(0,1), size = 1, replace = T, prob = c(.x, 1-.x)))
y = map_dbl(p, ~sample(c(0,1), size = 1, replace = T, prob = c(.x, 1-.x)))
y
p[y]
p
p[as.logical(y)]
p[as.logical(y)] %>% mean
y = map_dbl(p, ~sample(c(0,1), size = 1, replace = T, prob = c(1 - .x, .x)))
p[as.logical(y)] %>% mean
p[as.logical(1-y)] %>% mean
data <- data.frame(X1, X2, p, y)
data
data %>% ggplot(aes(x = X1, y = X2, color = y))
y
data %>% ggplot(aes(x = X1, y = X2, color = y)) + geom_point()
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point()
?glm
model <- glm(y1 ~ X1 + X2, binomial(link = "logit"), data = data)
model <- glm(y ~ X1 + X2, binomial(link = "logit"), data = data)
model
model <- glm(y ~ 0 + X1 + X2, binomial(link = "logit"), data = data)
model
coef(model)
beta <- coef(model)
b_hat <- coef(model)
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point()
a = - b_hat[1]/b_hat[2]
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a)
?seq
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a)
x1_grid = seq(-2, 2, 0.1)
x2_grid = seq(-2, 2, 0.1)
X1_grid = seq(-2, 2, 0.1)
X2_grid = seq(-2, 2, 0.1)
z = p = f_p(X1_grid, X2_grid, 2, 1)
z = f_p(X1_grid, X2_grid, 2, 1)
X!_grid
X1_grid
crossings(X1_grid, X2_grid)
crossing(X1_grid, X2_grid)
length(X1_grid)
41*41
X1_grid = seq(-2, 2, 0.1)
X2_grid = seq(-2, 2, 0.1)
grid_data = crossing(X1_grid, X2_grid)
grid_data <- mutate(grid_data, z = f_p(X1_grid, X2_grid, 2, 1))
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a)
data %>% names()
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(aes(x = X1_grid, y = X2_grid, z = z), data = grid_data)
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(mapping = aes(x = X1_grid, y = X2_grid, z = z), data = grid_data)
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(mapping = aes(x = X1_grid, y = X2_grid, z = z), data = grid_data)
grid_data <- mutate(grid_data, zval = f_p(X1_grid, X2_grid, 2, 1))
data %>% ggplot(aes(x = X1, y = X2, color = as.factor(y))) + geom_point() +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(mapping = aes(x = X1_grid, y = X2_grid, z = zval), data = grid_data)
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(aes(x = X1_grid, y = X2_grid, z = zval), data = grid_data)
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) %>%
geom_contour(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval))
?geom_point
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) #%>%
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval))
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval))
data$y = as.factor(y)
X1_grid = seq(-2.5, 2.5, 0.1)
X2_grid = seq(-2.5, 2.5, 0.1)
data$y = as.factor(y)
data %>% ggplot(aes(x = X1, y = X2, color = y)) + geom_point() +
geom_abline(intercept = 0, slope = a)
X1_grid = seq(-2.5, 2.5, 0.1)
X2_grid = seq(-2.5, 2.5, 0.1)
grid_data = crossing(X1_grid, X2_grid)
grid_data <- mutate(grid_data, zval = f_p(X1_grid, X2_grid, 2, 1))
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval))
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3)
pacman::p_load(tidyverse, viridis)
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_discrete_viridis()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis_b()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis_d()
?scale_fill_viridis
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis_d(option = "A")
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis_d(option = "B")
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .3) +
scale_fill_viridis_d(option = "B") +
theme_minimal()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .4) +
scale_fill_viridis_d(option = "B") +
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .4, breaks = seq(0, 1, 0.05)) +
scale_fill_viridis_d(option = "B") +
theme_minimal()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .4, breaks = seq(0, 1, 0.1)) +
scale_fill_viridis_d(option = "B") +
theme_minimal()
ggplot() + geom_point(data = data, aes(x = X1, y = X2, color = as.factor(y))) +
geom_abline(intercept = 0, slope = a) +
geom_contour_filled(data = grid_data, aes(x = X1_grid, y = X2_grid, z = zval),
alpha = .4, breaks = seq(0, 1, 0.08)) +
scale_fill_viridis_d(option = "B") +
theme_minimal()
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr)
library(OpenMx)
getOption('mxOptions')$"Number of Threads"
omxDetectCores()
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr)
set.seed(123)
induce_missing <- function(v, p){
miss <- sample(c(0,1), length(v), replace = TRUE, prob = c(1-p, p))
ifelse(miss, NA, v)
}
get_testpars <- function(fit) {
select(parameterEstimates(fit), lhs, op, rhs, est, se, p = pvalue, z)
}
library(OpenMx)
getOption('mxOptions')$"Number of Threads"
Demo.growth %<>% mutate(
load_t1 = rep(0, 400),
load_t2 = c(rep(0.5, 200), rep(1.5, 200)),
load_t3 = c(rep(1.5, 200), rep(2.5, 200)),
load_t4 = c(rep(2.5, 200), rep(3.5, 200))
)
pacman::p_load(here, feather, tidyverse, lavaan, microbenchmark, magrittr)
set.seed(123)
induce_missing <- function(v, p){
miss <- sample(c(0,1), length(v), replace = TRUE, prob = c(1-p, p))
ifelse(miss, NA, v)
}
get_testpars <- function(fit) {
select(parameterEstimates(fit), lhs, op, rhs, est, se, p = pvalue, z)
}
library(OpenMx)
# big model ---------------------------------------------------------------
data_big <- data.frame(load_t1 = rep(1, 500))
for(i in 1:15){
name <- str_c("load_t", i)
data_big[[name]] <- i
}
data_big %<>% mutate(across(contains("load"), function(x)x+rnorm(500, 0, 0.5)))
#dataRaw <- mxData( observed=Demo.growth, type="raw" )
# residual variances
resVars <- mxPath( from=str_c("t", 1:15), arrows=2,
free=TRUE, values = rep(1, 15))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1,1,1), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:15), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = str_c("data.load_t", 1:15))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:15), arrows=1,
free=FALSE, values=rep(0,15) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,0.5), labels=c("meani","means") )
dataRaw_big <- mxData( observed=data_big, type="raw" )
growthCurveModel_big <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t",1:15),
latentVars=c("intercept","slope"),
dataRaw_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
data_mx_big <- mxGenerateData(growthCurveModel_big)
dataRaw_mx_big <- mxData( observed=data_mx_big, type="raw" )
growthCurveModel_big <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:15),
latentVars=c("intercept","slope"),
dataRaw_mx_big,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
mxOption(model= growthCurveModel_big, key="Number of Threads", value= 1)
microbenchmark(mxRun(growthCurveModel_big), times = 1)
microbenchmark(mxRun(growthCurveModel_big), times = 1)
mxOption(model= growthCurveModel_big, key="Number of Threads", value= 2)
microbenchmark(mxRun(growthCurveModel_big), times = 1)
mxOption(model= growthCurveModel_big, key="Number of Threads", value= 4)
mxOption(model= growthCurveModel_big, key="Number of Threads", value= 4)
microbenchmark(mxRun(growthCurveModel_big), times = 1)
omxDetectCores()
pacman::p_load(here, feather, tidyverse, magrittr, ggplot2)
setwd(r"(C:\Users\maxim\.julia\dev\sem)")
BFGS_results = read_csv("test/comparisons/benchmark_big.csv")
BFGS_results %<>% mutate(is_finite = !is.infinite(minimum))
BFGS_results %>% ggplot() + geom_point(aes(x = line_search, y = is_finite))
BFGS_results %>% group_by(line_search) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% group_by(step_length) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% group_by(algo) %>% summarise(n_inf = sum(!is_finite))
BFGS_results %>% ggplot() +
geom_point(aes(x = line_search,
y = interaction(step_length, algo, m),
color = truepars,
shape = algo),
#position = position_jitter(width = 1),
alpha = 0.7) +
theme_minimal()
BFGS_results %>% ggplot() +
geom_point(aes(x = step_length, y = time, color = factor(m),
group = interaction(line_search, algo, m)),
alpha = .5) +
facet_grid(rows = vars(line_search), cols = vars(algo)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
theme_minimal()
BFGS_results %>% ggplot() +
geom_point(aes(x = step_length, y = time, color = factor(m),
group = interaction(line_search, algo, m)),
alpha = .5) +
facet_grid(rows = vars(line_search), cols = vars(algo)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
BFGS_results %<>% filter(truepars)
BFGS_results %>% ggplot() +
geom_point(aes(x = step_length, y = time, color = factor(m),
group = interaction(line_search, algo, m)),
alpha = .5) +
facet_grid(rows = vars(line_search), cols = vars(algo)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
BFGS_results %>% ggplot() +
geom_point(aes(x = step_length, y = time, color = factor(m),
group = interaction(line_search, algo, m)),
alpha = .5) +
facet_grid(rows = vars(line_search), cols = vars(algo)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
coord_cartesian(ylim=c(0, 30))
getOption('mxOptions')$"Number of Threads"
library(OpenMx)
getOption('mxOptions')$"Number of Threads"
omxDetectCores()
omxDetectCores() # return 8
getOption('mxOptions')$"Number of Threads" # returns 2
mxOption(model= yourModel, key="Number of Threads", value= (omxDetectCores() - 1)) #does not change time to fit the model, regardless of the value I pass
?setOption
?getOption
getOption('mxOptions')$"Number of Threads" <- 4
getOption('mxOptions')$"Number of Threads"
options("mxOptions")
options("mxOptions")$"Number of Threads"
options("mxOptions")[[1]]$"Number of Threads"
options("mxOptions")[[1]]$"Number of Threads" <- 4
library(dplyr, OpenMx)
set.seed(2343253)
ntime = 30
nobs = 500
data <- data.frame(load_t1 = rep(1, nobs))
for(i in 1:30){
name <- str_c("load_t", i)
data[[name]] <- i
}
data <- mutate(data, across(contains("load"), function(x)x+rnorm(nobs, 0, 0.1)))
# residual variances
resVars <- mxPath( from=str_c("t", 1:ntime), arrows=2,
free=TRUE, values = rnorm(ntime, 5, 2))
?library
library(dplyr)
library(OpenMx)
set.seed(2343253)
ntime = 30
nobs = 500
data <- data.frame(load_t1 = rep(1, nobs))
for(i in 1:30){
name <- str_c("load_t", i)
data[[name]] <- i
}
data <- mutate(data, across(contains("load"), function(x)x+rnorm(nobs, 0, 0.1)))
# residual variances
resVars <- mxPath( from=str_c("t", 1:ntime), arrows=2,
free=TRUE, values = rnorm(ntime, 5, 2))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1.8,0.1,0.2), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = str_c("data.load_t", 1:ntime))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(0,ntime) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6), labels=c("meani","means") )
dataRaw <- mxData( observed=select(data, contains("load")), type="raw" )
library(dplyr)
library(OpenMx)
library(stringr)
set.seed(2343253)
ntime = 30
nobs = 500
data <- data.frame(load_t1 = rep(1, nobs))
for(i in 1:30){
name <- str_c("load_t", i)
data[[name]] <- i
}
data <- mutate(data, across(contains("load"), function(x)x+rnorm(nobs, 0, 0.1)))
# residual variances
resVars <- mxPath( from=str_c("t", 1:ntime), arrows=2,
free=TRUE, values = rnorm(ntime, 5, 2))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1.8,0.1,0.2), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = str_c("data.load_t", 1:ntime))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(0,ntime) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6), labels=c("meani","means") )
library(dplyr)
library(OpenMx)
library(stringr)
set.seed(2343253)
ntime = 30
nobs = 500
data <- data.frame(load_t1 = rep(1, nobs))
for(i in 1:30){
name <- str_c("load_t", i)
data[[name]] <- i
}
data <- mutate(data, across(contains("load"), function(x)x+rnorm(nobs, 0, 0.1)))
# residual variances
resVars <- mxPath( from=str_c("t", 1:ntime), arrows=2,
free=TRUE, values = rnorm(ntime, 5, 2))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1.8,0.1,0.2), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = str_c("data.load_t", 1:ntime))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(0,ntime) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1.4,0.6), labels=c("meani","means") )
dataRaw <- mxData( observed=select(data, contains("load")), type="raw" )
growthCurveModel_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t",1:ntime),
latentVars=c("intercept","slope"),
dataRaw_huge,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
# simulated data
data_mx <- mxGenerateData(growthCurveModel_true)
growthCurveModel_true <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t",1:ntime),
latentVars=c("intercept","slope"),
dataRaw,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
# simulated data
data_mx <- mxGenerateData(growthCurveModel_true)
dataRaw_mx <- mxData(observed=data_mx, type="raw")
resVars <- mxPath( from=str_c("t", 1:ntime), arrows=2,
free=TRUE, values = rep(1, ntime))
# latent variances and covariance
latVars <- mxPath( from=c("intercept","slope"), arrows=2, connect="unique.pairs",
free=TRUE, values=c(1,1,1), labels=c("vari","cov","vars") )
# intercept loadings
intLoads <- mxPath( from="intercept", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(1,15) )
# slope loadings
sloLoads <- mxPath( from="slope", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, #values=c(0,1,2,3),
labels = str_c("data.load_t", 1:ntime))
# manifest means
manMeans <- mxPath( from="one", to=str_c("t", 1:ntime), arrows=1,
free=FALSE, values=rep(0,ntime) )
# latent means
latMeans <- mxPath( from="one", to=c("intercept", "slope"), arrows=1,
free=TRUE, values=c(1,1), labels=c("meani","means") )
dataRaw_huge <- mxData( observed=data_huge, type="raw" )
growthCurveModel_huge <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:ntime),
latentVars=c("intercept","slope"),
dataRaw_mx_huge,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit <- mxRun(growthCurveModel)
growthCurveModel_huge <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:ntime),
latentVars=c("intercept","slope"),
dataRaw_mx,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit <- mxRun(growthCurveModel)
growthCurveModel <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=str_c("t", 1:ntime),
latentVars=c("intercept","slope"),
dataRaw_mx,
resVars, latVars, intLoads, sloLoads,
manMeans, latMeans)
growthCurveFit <- mxRun(growthCurveModel)
summary(growthCurveFit)
omxDetectCores() # return 8
getOption('mxOptions')$"Number of Threads" # returns 2
mxOption(model= growthCurveModel, key="Number of Threads",
value= (omxDetectCores() - 1))
growthCurveFit <- mxRun(growthCurveModel)
summary(growthCurveFit_huge)
summary(growthCurveFit)
